#!/usr/bin/env python3
"""
镜像文档解析器 - 从Markdown文档生成shell脚本

该程序读取镜像仓库中的markdown文档，解析其中的yaml cli和yaml cli-nodocs代码块，
并根据detection配置生成对应的自动操作换源shell脚本。

支持的yaml cli类型：
- ReplaceIfExist: 替换文件中的匹配内容
- TestAndExecute: 测试条件后执行命令
- Execute: 直接执行命令
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Tuple

import yaml


class MarkdownParser:
    """Markdown文档解析器"""
    
    def __init__(self, docs_dir: str = "docs"):
        self.docs_dir = Path(docs_dir)
        self.gen_tag = "Generated by hust-mirrors auto script"
        
    def parse_frontmatter(self, content: str) -> Tuple[Dict[str, Any], str]:
        """解析markdown前置元数据"""
        if not content.startswith('---'):
            return {}, content
            
        parts = content.split('---', 2)
        if len(parts) < 3:
            return {}, content
            
        try:
            frontmatter = yaml.safe_load(parts[1])
            remaining_content = parts[2]
            return frontmatter or {}, remaining_content
        except yaml.YAMLError:
            return {}, content
    
    def extract_yaml_cli_blocks(self, content: str) -> List[Dict[str, Any]]:
        """提取yaml cli和yaml cli-nodocs代码块"""
        blocks = []
        
        # 匹配yaml cli和yaml cli-nodocs代码块
        pattern = r'```yaml cli(?:-nodocs)?\n(.*?)\n```'
        matches = re.findall(pattern, content, re.DOTALL)
        
        for match in matches:
            try:
                yaml_data = yaml.safe_load(match)
                if yaml_data:
                    blocks.append(yaml_data)
            except yaml.YAMLError as e:
                print(f"Warning: Failed to parse YAML block: {e}")
                continue
                
        return blocks
    
    def parse_markdown_file(self, file_path: Path) -> Dict[str, Any]:
        """解析单个markdown文件"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
            return {}
            
        frontmatter, body_content = self.parse_frontmatter(content)
        yaml_blocks = self.extract_yaml_cli_blocks(body_content)
        
        return {
            'file_path': file_path,
            'frontmatter': frontmatter,
            'yaml_blocks': yaml_blocks
        }
    
    def generate_check_function(self, detection: Dict[str, Any], mirror_id: str) -> str:
        """根据detection配置生成check函数"""
        if not detection:
            return f"""check() {{
	# No detection rules specified for {mirror_id}
	return 0
}}"""
        
        checks = detection.get('checks', [])
        policy = detection.get('policy', 'AllOf')  # 默认所有条件都要满足
        
        if not checks:
            return f"""check() {{
	# No checks specified for {mirror_id}
	return 0
}}"""
        
        check_lines = []
        check_lines.append("check() {")
        
        # 如果有os_release类型的检查，先source
        for check in checks:
            if check.get('type') == 'os_release':
                check_lines.append("\tsource_os_release")
                break
        
        conditions = []
        for check in checks:
            check_type = check.get('type', '')
            
            if check_type == 'os_release':
                name = check.get('name', '')
                if name:
                    conditions.append(f'[ "$NAME" = "{name}" ]')
            elif check_type == 'command':
                command = check.get('command', '')
                if command:
                    conditions.append(f'has_command {command}')
            else:
                print(f"Warning: Unknown check type: {check_type}")
        
        if not conditions:
            check_lines.append("\treturn 0")
        elif policy == 'OneOf':
            # 任一条件满足即可
            condition_str = ' || '.join(conditions)
            check_lines.append(f"\t{condition_str}")
        else:
            # 默认AllOf：所有条件都要满足
            condition_str = ' && '.join(conditions)
            check_lines.append(f"\t{condition_str}")
        
        check_lines.append("}")
        
        return '\n'.join(check_lines)
    
    def generate_replace_function(self, yaml_block: Dict[str, Any], func_name: str, mirror_id: str) -> str:
        """生成ReplaceIfExist类型的函数"""
        files = yaml_block.get('files', [])
        privileged = yaml_block.get('privileged', False)
        optional = yaml_block.get('optional', False)
        description = yaml_block.get('description', 'Replace configuration')
        
        lines = []
        lines.append(f"{func_name}() {{")
        lines.append(f"\t# {description}")
        
        # 如果是可选的，先确认是否执行
        if optional:
            lines.append(f"\tconfirm_y \"{description}?\" || return 0")
            lines.append("")
        
        if privileged:
            lines.append("\tset_sudo")
            lines.append("")
        
        for file_config in files:
            path = file_config.get('path', '')
            match_pattern = file_config.get('match', '')
            replace_pattern = file_config.get('replace', '')
            comment = file_config.get('comment', '')
            
            if not all([path, match_pattern, replace_pattern]):
                continue
                
            if comment:
                lines.append(f"\t# {comment.lstrip('> ')}")
            
            # 创建备份
            lines.append(f"\tif [ -f \"{path}\" ]; then")
            sudo_prefix = "$sudo " if privileged else ""
            lines.append(f"\t\t{sudo_prefix}cp \"{path}\" \"{path}.bak\" || {{")
            lines.append(f"\t\t\tprint_error \"Backup {path} failed\"")
            lines.append(f"\t\t\treturn 1")
            lines.append(f"\t\t}}")
            
            # 执行替换
            # 处理变量替换：${_http} -> $http, ${_domain} -> $domain
            replace_processed = replace_pattern.replace('${_http}', '$http').replace('${_domain}', '$domain')
            match_processed = match_pattern.replace('${_http}', '$http').replace('${_domain}', '$domain')
            
            # 转义sed命令中的特殊字符
            replace_escaped = replace_processed.replace('/', r'\/')
            match_escaped = match_processed.replace('/', r'\/')
            
            lines.append(f"\t\t{sudo_prefix}sed -i 's|{match_escaped}|{replace_escaped}|g' \"{path}\" || {{")
            lines.append(f"\t\t\tprint_error \"Failed to update {path}\"")
            lines.append(f"\t\t\treturn 1")
            lines.append(f"\t\t}}")
            lines.append(f"\telse")
            lines.append(f"\t\tprint_warning \"File {path} does not exist\"")
            lines.append(f"\tfi")
            lines.append("")
        
        lines.append("\treturn 0")
        lines.append("}")
        
        return '\n'.join(lines)
    
    def generate_test_execute_function(self, yaml_block: Dict[str, Any], func_name: str, mirror_id: str) -> str:
        """生成TestAndExecute类型的函数"""
        test_script = yaml_block.get('test', '').strip()
        exec_script = yaml_block.get('exec', '').strip()
        privileged = yaml_block.get('privileged', False)
        optional = yaml_block.get('optional', False)
        provide_backup = yaml_block.get('provide_backup', False)
        description = yaml_block.get('description', 'Test and execute')
        
        lines = []
        lines.append(f"{func_name}() {{")
        lines.append(f"\t# {description}")
        
        # 如果是可选的，先确认是否执行
        if optional:
            lines.append(f"\tconfirm_y \"{description}?\" || return 0")
            lines.append("")
        
        if privileged:
            lines.append("\tset_sudo")
            lines.append("")
        
        # 如果需要备份路径，设置备份文件变量
        if provide_backup:
            lines.append(f"\tbackup_path=\"/tmp/{mirror_id}_backup_$(date +%s)\"")
            lines.append("")
        
        # 添加测试部分
        if test_script:
            lines.append("\t# Test conditions")
            for line in test_script.split('\n'):
                line = line.strip()
                if line:
                    # 转义引号以避免shell语法错误
                    line_escaped = line.replace('"', '\\"')
                    lines.append(f"\t{line} || {{")
                    lines.append(f"\t\tprint_warning \"Test condition failed: {line_escaped}\"")
                    lines.append(f"\t\treturn 1")
                    lines.append(f"\t}}")
            lines.append("")
        
        # 添加执行部分
        if exec_script:
            lines.append("\t# Execute commands")
            # 处理备份路径替换
            if provide_backup:
                exec_script = exec_script.replace('{.backup.path}', '$backup_path')
            
            # 处理文档标记 #{USE_IN_DOCS/} 和 #{/USE_IN_DOCS}
            # 这些标记内的内容应该被保留，而标记本身应该被移除
            exec_script = re.sub(r'#\{USE_IN_DOCS/\}\s*\n?', '', exec_script)
            exec_script = re.sub(r'\s*#\{/USE_IN_DOCS\}', '', exec_script)
            
            # 处理变量替换
            exec_script = exec_script.replace('${_domain}', '$domain').replace('${_http}', '$http')
            
            sudo_prefix = "$sudo " if privileged else ""
            in_heredoc = False
            heredoc_delimiter = None
            
            for line in exec_script.split('\n'):
                original_line = line
                line = line.strip()
                
                if not line:
                    continue
                
                # 检测here-document开始
                if '<<' in line and not in_heredoc:
                    # 查找分隔符
                    parts = line.split('<<', 1)
                    if len(parts) == 2:
                        delimiter_part = parts[1].strip()
                        if delimiter_part:
                            heredoc_delimiter = delimiter_part.split()[0]
                            in_heredoc = True
                            if line.startswith('mkdir') or line.startswith('cp') or line.startswith('mv') or line.startswith('cat') or line.startswith('touch'):
                                lines.append(f"\t{sudo_prefix}{line}")
                            else:
                                lines.append(f"\t{line}")
                            continue
                
                # 检测here-document结束
                if in_heredoc and line == heredoc_delimiter:
                    lines.append(line)  # EOF不加制表符前缀
                    in_heredoc = False
                    heredoc_delimiter = None
                    continue
                
                # here-document内容
                if in_heredoc:
                    lines.append(original_line)  # 保持原始缩进
                    continue
                    
                # 普通命令
                if line.startswith('mkdir') or line.startswith('cp') or line.startswith('mv') or line.startswith('cat >') or line.startswith('touch'):
                    lines.append(f"\t{sudo_prefix}{line}")
                else:
                    lines.append(f"\t{line}")
        
        lines.append("")
        lines.append("\treturn 0")
        lines.append("}")
        
        return '\n'.join(lines)
    
    def generate_execute_function(self, yaml_block: Dict[str, Any], func_name: str, mirror_id: str) -> str:
        """生成Execute类型的函数"""
        exec_script = yaml_block.get('exec', '').strip()
        privileged = yaml_block.get('privileged', False)
        optional = yaml_block.get('optional', False)
        description = yaml_block.get('description', 'Execute commands')
        interpreter = yaml_block.get('interpreter', 'shell')
        
        lines = []
        lines.append(f"{func_name}() {{")
        lines.append(f"\t# {description}")
        
        # 如果是可选的，先确认是否执行
        if optional:
            lines.append(f"\tconfirm_y \"{description}?\" || return 0")
            lines.append("")
        
        if privileged:
            lines.append("\tset_sudo")
            lines.append("")
        
        # 添加执行部分
        if exec_script:
            lines.append("\t# Execute commands")
            
            # 处理文档标记 #{USE_IN_DOCS/} 和 #{/USE_IN_DOCS}
            exec_script = re.sub(r'#\{USE_IN_DOCS/\}\s*\n?', '', exec_script)
            exec_script = re.sub(r'\s*#\{/USE_IN_DOCS\}', '', exec_script)
            
            # 处理变量替换
            exec_script = exec_script.replace('${_domain}', '$domain').replace('${_http}', '$http')
            
            sudo_prefix = "$sudo " if privileged else ""
            in_heredoc = False
            heredoc_delimiter = None
            
            for line in exec_script.split('\n'):
                original_line = line
                line = line.strip()
                
                if not line:
                    continue
                
                # 检测here-document开始
                if '<<' in line and not in_heredoc:
                    parts = line.split('<<', 1)
                    if len(parts) == 2:
                        delimiter_part = parts[1].strip()
                        if delimiter_part:
                            heredoc_delimiter = delimiter_part.split()[0]
                            in_heredoc = True
                            if line.startswith('mkdir') or line.startswith('cp') or line.startswith('mv') or line.startswith('cat') or line.startswith('touch'):
                                lines.append(f"\t{sudo_prefix}{line}")
                            else:
                                lines.append(f"\t{line}")
                            continue
                
                # 检测here-document结束
                if in_heredoc and line == heredoc_delimiter:
                    lines.append(line)  # EOF不加制表符前缀
                    in_heredoc = False
                    heredoc_delimiter = None
                    continue
                
                # here-document内容
                if in_heredoc:
                    lines.append(original_line)  # 保持原始缩进
                    continue
                    
                # 普通命令
                if line.startswith('mkdir') or line.startswith('cp') or line.startswith('mv') or line.startswith('cat >') or line.startswith('touch'):
                    lines.append(f"\t{sudo_prefix}{line}")
                else:
                    lines.append(f"\t{line}")
        
        lines.append("")
        lines.append("\treturn 0")
        lines.append("}")
        
        return '\n'.join(lines)
    
    def generate_shell_script(self, parsed_data: Dict[str, Any]) -> str:
        """生成完整的shell脚本"""
        frontmatter = parsed_data['frontmatter']
        yaml_blocks = parsed_data['yaml_blocks']
        
        mirror_id = frontmatter.get('id')
        if not mirror_id:
            # 从sidebar_label或文件名推断ID
            mirror_label = frontmatter.get('sidebar_label', '')
            if mirror_label:
                mirror_id = mirror_label.lower().replace(' ', '-')
            else:
                mirror_id = parsed_data['file_path'].stem
        
        mirror_label = frontmatter.get('sidebar_label', mirror_id)
        detection = frontmatter.get('detection', {})
        
        script_lines = []
        script_lines.append(f"#!/bin/bash")
        script_lines.append(f"# Auto-generated script for {mirror_label}")
        script_lines.append(f"# Generated from: {parsed_data['file_path'].name}")
        script_lines.append(f"# Mirror ID: {mirror_id}")
        script_lines.append(f"")
        script_lines.append(f"gen_tag=\"{self.gen_tag}\"")
        script_lines.append(f"")
        
        # 生成check函数
        check_function = self.generate_check_function(detection, mirror_id)
        script_lines.append(check_function)
        script_lines.append("")
        
        # 为每个yaml block生成函数
        install_functions = []
        for i, yaml_block in enumerate(yaml_blocks):
            block_type = yaml_block.get('type', '')
            func_name = f"_{mirror_id}_install_{i+1}"
            
            if block_type == 'ReplaceIfExist':
                func_code = self.generate_replace_function(yaml_block, func_name, mirror_id)
                script_lines.append(func_code)
                script_lines.append("")
                install_functions.append(func_name)
            elif block_type == 'TestAndExecute':
                func_code = self.generate_test_execute_function(yaml_block, func_name, mirror_id)
                script_lines.append(func_code)
                script_lines.append("")
                install_functions.append(func_name)
            elif block_type == 'Execute':
                func_code = self.generate_execute_function(yaml_block, func_name, mirror_id)
                script_lines.append(func_code)
                script_lines.append("")
                install_functions.append(func_name)
            else:
                print(f"Warning: Unknown yaml block type: {block_type}")
        
        # 生成主install函数
        if install_functions:
            script_lines.append("install() {")
            for func_name in install_functions:
                script_lines.append(f"\t{func_name} || return 1")
            script_lines.append("\tprint_success \"Mirror configuration updated successfully\"")
            script_lines.append("}")
            script_lines.append("")
        else:
            script_lines.append("install() {")
            script_lines.append("\tprint_warning \"No installation functions generated\"")
            script_lines.append("\treturn 1")
            script_lines.append("}")
            script_lines.append("")
        
        # 生成uninstall和其他标准函数
        script_lines.extend([
            "uninstall() {",
            "\t# Try to restore backup files",
            "\tprint_info \"Looking for backup files...\"",
            "\tfind /etc /usr/local/etc ~/.config -name \"*.bak\" -type f 2>/dev/null | while read -r backup_file; do",
            "\t\toriginal_file=\"${backup_file%.bak}\"",
            "\t\tif [ -f \"$backup_file\" ]; then",
            "\t\t\tset_sudo",
            "\t\t\t$sudo mv \"$backup_file\" \"$original_file\" && print_success \"Restored $original_file\"",
            "\t\tfi",
            "\tdone",
            "}",
            "",
            "is_deployed() {",
            "\t# Check if any config file contains our generation tag",
            "\tgrep -r \"$gen_tag\" /etc /usr/local/etc ~/.config 2>/dev/null >/dev/null",
            "}",
            "",
            "can_recover() {",
            "\t# Check if backup files exist",
            "\tfind /etc /usr/local/etc ~/.config -name \"*.bak\" -type f 2>/dev/null | head -1 | grep -q .",
            "}",
        ])
        
        return '\n'.join(script_lines)
    
    def process_all_docs(self, output_dir: str = "generated_scripts") -> None:
        """处理所有文档并生成脚本"""
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        if not self.docs_dir.exists():
            print(f"Error: Documentation directory {self.docs_dir} does not exist")
            return
            
        processed_count = 0
        
        for md_file in self.docs_dir.glob("*.md"):
            parsed_data = self.parse_markdown_file(md_file)
            
            if not parsed_data.get('yaml_blocks'):
                print(f"Skipping {md_file.name}: No yaml cli blocks found")
                continue
            
            mirror_id = parsed_data['frontmatter'].get('id')
            if not mirror_id:
                print(f"Warning: No ID found in {md_file.name}, using filename")
                mirror_id = md_file.stem
            
            script_content = self.generate_shell_script(parsed_data)
            
            output_file = output_path / f"{mirror_id}.sh"
            try:
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(script_content)
                print(f"Generated: {output_file}")
                processed_count += 1
            except Exception as e:
                print(f"Error writing {output_file}: {e}")
        
        print(f"\nProcessed {processed_count} documentation files")


def main():
    """主函数"""
    parser = argparse.ArgumentParser(
        description="Generate shell scripts from mirror documentation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument(
        'docs_dir',
        nargs='?',
        default='docs',
        help='Directory containing markdown documentation files (default: docs)'
    )
    
    parser.add_argument(
        '-o', '--output',
        default='generated_scripts',
        help='Output directory for generated scripts (default: generated_scripts)'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    
    args = parser.parse_args()
    
    if args.verbose:
        print(f"Parsing documentation from: {args.docs_dir}")
        print(f"Output directory: {args.output}")
    
    try:
        markdown_parser = MarkdownParser(args.docs_dir)
        markdown_parser.process_all_docs(args.output)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()